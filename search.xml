<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>比赛系列（全国智能车大赛）——舵机篇</title>
      <link href="/2023/03/30/20-39-12/"/>
      <url>/2023/03/30/20-39-12/</url>
      
        <content type="html"><![CDATA[<h2 id="比赛系列（全国智能车大赛）——舵机篇"><a href="#比赛系列（全国智能车大赛）——舵机篇" class="headerlink" title="比赛系列（全国智能车大赛）——舵机篇"></a>比赛系列（全国智能车大赛）——舵机篇</h2><h4 id="思路显示"><a href="#思路显示" class="headerlink" title="思路显示"></a>思路显示</h4><p><img src="C:\Users\荆辉\AppData\Roaming\Typora\typora-user-images\image-20230330185229587.png" alt="image-20230330185229587"></p><h3 id="舵机介绍"><a href="#舵机介绍" class="headerlink" title="舵机介绍"></a>舵机介绍</h3><p><strong>舵机型号：S3010</strong></p><blockquote><p>舵机简单的说就是集成了直流电机、电机控制器和减速器等，并封装在一个便于安装的外壳里的伺服单元。能够利用简单的输入信号比较精确的转动给定角度的电机系统。</p></blockquote><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><blockquote><p>接线：</p><p>红：VCC，黑：地，白：信号线</p><p>舵机控制时根据信号线的高电平时间来确定角度的</p></blockquote><h4 id="电压"><a href="#电压" class="headerlink" title="电压"></a>电压</h4><hr><p>电压一般为5-7V，单片机控制使最好对舵机单独供电</p><hr><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><hr><p>如高电平时间为1ms时居中，高电平时间长向右转，高电平时间短向左转，</p><p>在智能车上控制方向的舵机，角度旋转一般再 <strong>45°到135°</strong></p><hr><p>舵机使用进行PWM控制，</p><p>当接收的PWM脉冲高电平 1ms时舵机居中（与占空比无关）</p><p>整个PWM的频率 决定了舵机的调整频率</p><blockquote><p>如以20ms为周期时，舵机20ms矫正一次角度</p><p>以3ms为周期时，舵机20ms矫正一次角度</p></blockquote><p><strong>直观的体现是舵机调节方向时的稳定性</strong></p><hr><h4 id="控制逻辑"><a href="#控制逻辑" class="headerlink" title="控制逻辑"></a>控制逻辑</h4><p>通过串口接收指令</p><p>通过对指令进行逻辑判断来对PWM占比进行调节，<strong>以改变高电平时间</strong></p><p>已到达对前轮方向的改变</p><hr><h3 id="配置需求"><a href="#配置需求" class="headerlink" title="配置需求"></a>配置需求</h3><hr><blockquote><p><strong>基于STM32F407，舵机控制通用定时器即可（定时器一为高级定时器），串口一与定时器八冲突，</strong></p><p><strong>请勿同时使用</strong></p></blockquote><hr><h4 id="定时器-定时器1"><a href="#定时器-定时器1" class="headerlink" title="定时器(定时器1)"></a>定时器(定时器1)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM1_PWM_Init</span><span class="params">(u32 arr,u32 psc)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;</span><br><span class="line">TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);<span class="comment">//TIM5 时钟使能</span></span><br><span class="line">RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE); <span class="comment">//使能 GPIOE 时钟</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GPIO_PinAFConfig(GPIOE,GPIO_PinSource11,GPIO_AF_TIM1); <span class="comment">//GE11 复用为 TIM1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; <span class="comment">//GPIOE11</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; <span class="comment">//复用功能</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz; <span class="comment">//速度 50MHz</span></span><br><span class="line">GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; <span class="comment">//推挽复用输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; <span class="comment">//上拉</span></span><br><span class="line">GPIO_Init(GPIOE,&amp;GPIO_InitStructure); <span class="comment">//初始化 PE11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler=(psc<span class="number">-1</span>); <span class="comment">//定时器分频</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up; <span class="comment">//向上计数模式</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_Period=(arr<span class="number">-1</span>); <span class="comment">//自动重装载值</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseStructure);<span class="comment">//初始化定时器 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 TIM14 Channel1 PWM 模式</span></span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; <span class="comment">//PWM 调制模式 1</span></span><br><span class="line">TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">//比较输出使能</span></span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low; <span class="comment">//输出极性低</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_OC2Init(TIM1, &amp;TIM_OCInitStructure); <span class="comment">//初始化外设 </span></span><br><span class="line">TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable); <span class="comment">//使能预装载寄存器</span></span><br><span class="line">TIM_ARRPreloadConfig(TIM1,ENABLE);<span class="comment">//ARPE 使能</span></span><br><span class="line">TIM_Cmd(TIM1, ENABLE); <span class="comment">//使能 TIM1</span></span><br><span class="line">TIM_CtrlPWMOutputs(TIM1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="串口-串口一"><a href="#串口-串口一" class="headerlink" title="串口(串口一)"></a>串口(串口一)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Common_Usart1_Config</span><span class="params">(Common_USART_Sturct* Normal_USART_Init)</span>  <span class="comment">//串口初始化</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE); <span class="comment">//开启串口时钟</span></span><br><span class="line">RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);<span class="comment">//开启对应GPOIO时钟</span></span><br><span class="line">GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1);<span class="comment">//GPIO复用函数</span></span><br><span class="line">GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;                     <span class="comment">//初始化GPIO结构体</span></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9|GPIO_Pin_10;  </span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;              <span class="comment">//复用模式</span></span><br><span class="line">GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">USART_InitTypeDef USART_InitStruct;         <span class="comment">//串口结构体初始化</span></span><br><span class="line">USART_InitStruct.USART_BaudRate = Normal_USART_Init-&gt;USART_BaudRate;</span><br><span class="line">USART_InitStruct.USART_WordLength = Normal_USART_Init-&gt;USART_WordLength;</span><br><span class="line">USART_InitStruct.USART_StopBits = Normal_USART_Init-&gt;USART_StopBits;</span><br><span class="line">USART_InitStruct.USART_Parity = Normal_USART_Init-&gt;USART_Parity;</span><br><span class="line">USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">USART_InitStruct.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;</span><br><span class="line">USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);<span class="comment">//开启串口中断</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//Usart1 NVIC 配置</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">NVIC_PriorityGroupConfig(Normal_USART_Init-&gt;NVIC_PriorityGroup);<span class="comment">// 配置 NVIC 为优先级组</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=Normal_USART_Init-&gt;Prepro;</span><br><span class="line">    <span class="comment">//抢占优先级 </span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority =Normal_USART_Init-&gt;Subpro; <span class="comment">//响应优先级 </span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//IRQ 通道使能</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure); </span><br><span class="line">USART_Cmd(USART1, ENABLE); <span class="comment">//使能串口 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式C语言（宏定义）</title>
      <link href="/2023/03/28/16-00-44/"/>
      <url>/2023/03/28/16-00-44/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式C语言（宏定义）"><a href="#嵌入式C语言（宏定义）" class="headerlink" title="嵌入式C语言（宏定义）"></a>嵌入式C语言（宏定义）</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;头文件.h&quot; //引用头文件</span><br><span class="line"></span><br><span class="line">#define 宏名 宏体   // 宏定义</span><br><span class="line">#define STM32F10x  1 //将STM32F10x定义为1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="宏定义进阶"><a href="#宏定义进阶" class="headerlink" title="宏定义进阶"></a>宏定义进阶</h2><p><strong># 与 ##</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define STM32F10x #2763             //将STM32F10x替换为‘2763’（字符型）</span><br><span class="line"></span><br><span class="line">#define COMMON_TIM(x) TIM##(x)      // 将COMMON_TIM(x) 替换为TIM(x),如COMMON_TIM1 TIM1</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#if     条件1</span><br><span class="line"> //语句1</span><br><span class="line">#eli1f  条件2</span><br><span class="line"> //语句2</span><br><span class="line"> #endif </span><br><span class="line"></span><br><span class="line">#ifndef </span><br><span class="line">#define</span><br><span class="line">#endif </span><br><span class="line">与#if类似</span><br></pre></td></tr></table></figure><p>如果条件为1（真），则编译对应语句，</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void OUT_PP_Config(Common_GPIO_Sturct *Normal_GPIO_Init)</span><br><span class="line">&#123;</span><br><span class="line">#if STM32F10x</span><br><span class="line">    RCC_APB2PeriphClockCmd(Normal_GPIO_Init-&gt;RCC_AXXPeriph_GPIOX,ENABLE);</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;                   //推挽输出</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = STM32F10x_SPEED;   </span><br><span class="line">#elif STM32F4xx</span><br><span class="line">    RCC_AHB1PeriphClockCmd(Normal_GPIO_Init-&gt;RCC_AXXPeriph_GPIOX,ENABLE);       //开启时钟</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;</span><br><span class="line">    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;                           //上拉</span><br><span class="line">    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;                     //推挽输出模式</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = STM32F4xx_SPEED;   </span><br><span class="line">#endif</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = Normal_GPIO_Init-&gt;GPIO_PIN;                                  //配置引脚                                  </span><br><span class="line">    GPIO_Init(Normal_GPIO_Init-&gt;GPIOX,&amp;GPIO_InitStruct);</span><br><span class="line">    GPIO_SetBits(Normal_GPIO_Init-&gt;GPIOX,Normal_GPIO_Init-&gt;GPIO_PIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在头文件中修改STM32F10x，STM32F4xx的值即可切换版本</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gcc学习笔记</title>
      <link href="/2023/03/27/17-10-58/"/>
      <url>/2023/03/27/17-10-58/</url>
      
        <content type="html"><![CDATA[<h1 id="gcc学习笔记（无详细使用）"><a href="#gcc学习笔记（无详细使用）" class="headerlink" title="gcc学习笔记（无详细使用）"></a>gcc学习笔记（无详细使用）</h1><hr><h2 id="gcc-是什么"><a href="#gcc-是什么" class="headerlink" title="gcc 是什么"></a>gcc 是什么</h2><hr><blockquote><p>GCC : 英文全拼：GNU Compiler Collection，是 GNU 工具链的主要组成部分，是一套以 GPL 和 LGPL 许可证发布的程序语言编译器自由软件。</p></blockquote><blockquote><p>gcc ：GNU C Collection ，是一款C编译器，可以来编译C，C++</p></blockquote><blockquote><p>g++:GNU C++ Collection，是一款C++编译器，只C++专用</p></blockquote><p><strong>一般来说，gcc☞的都是GNU Compiler Collection，即GUN编译器合集</strong></p><hr><h2 id="gcc-怎么用"><a href="#gcc-怎么用" class="headerlink" title="gcc 怎么用"></a>gcc 怎么用</h2><hr><blockquote><p>gcc 在linux环境中通过命令来进行编译，在wins环境下，一般集成与单独的编译软件中，例如Dev-C++.</p><p>wins环境下，一般通过使用集成编译器间接使用（即图像化一键编译等等）,不过多解释。</p></blockquote><blockquote><p>另外，在Linux环境中，一般自带有gcc(C编译)，其他编译环境需要自行安装。linux下，通常以命令如：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o &#123;输出文件名&#125; &#123;输入文件名&#125;#-o与&#123;输出文件名&#125;之间不能有其他命令，两者可以看为一体</span><br><span class="line"></span><br><span class="line">#gcc对文件格式的识别是通过后缀进行的，后缀不同，gcc会选用不同的编译器</span><br></pre></td></tr></table></figure><blockquote><p> 另外的除了gcc命令外，还有g++命令,不过两者命令格式一样，不单独讨论了，只需要将命令中的gcc</p><p>换成g++即可</p></blockquote><p>具体使用可参考<a href="https://blog.csdn.net/Three_dog/article/details/103688043">g++编译详解</a>、<a href="https://zhuanlan.zhihu.com/p/380180101">gcc编译详解</a>。</p><hr><h2 id="gcc-什么时候用"><a href="#gcc-什么时候用" class="headerlink" title="gcc 什么时候用"></a>gcc 什么时候用</h2><hr><p>gcc，用在高级语言转机器语言的过程中，类似人与计算机之间的翻译员，将高级程序语言转化为二进制码</p><p>同时，其还可以找出高级语言中的语法错误，给出提示信息</p><p>我们也可以通过gcc获得相应高级语言的汇编语言、机器语言。</p><hr><h2 id="gcc的工作步骤"><a href="#gcc的工作步骤" class="headerlink" title="gcc的工作步骤"></a>gcc的工作步骤</h2><hr><blockquote><p>1、预处理 预编译，可以使用命令<code>gcc -E</code>执行</p></blockquote><blockquote><p>2、将预处理后的文件转换成汇编语言, 生成文件 .s      编译，可以使用<code>gcc -S</code>执行</p></blockquote><blockquote><p>3、有汇编变为目标代码(机器代码)生成 .o 的文件    汇编，可以使用<code>as</code> 或者<code>gcc -c</code>执行</p></blockquote><blockquote><p>4、连接目标代码, 生成可执行程序     链接，可以使用<code>gcc xxx.o xxx.so xxx.a</code>执行</p></blockquote><p>一步步向底层进发。gcc -o 【输出目标】 【输出目标】可以用不到位的进行，但本质上还是分布进行的</p><p>通过gcc -v -o 【输出目标】 【输出目标】可以显示他的编译步骤 (g++同理)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令笔记</title>
      <link href="/2023/03/24/18-40-36/"/>
      <url>/2023/03/24/18-40-36/</url>
      
        <content type="html"><![CDATA[<h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a><strong>linux常用命令</strong></h2><h3 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a><strong>文件操作：</strong></h3><blockquote><p><strong>cd</strong>:路径进入</p><p>cd 桌面 -进入桌面目录，cd &#x2F;进入根目录 ，**&#x2F;**代表根目录 ，..代表上一级，-代表当前目录</p></blockquote><blockquote><p><strong>ls</strong>：显示当前目录下文件</p><p>ls -a显示当前目录下所有文件（包括隐藏文件）</p></blockquote><blockquote><p>mkdir :文件夹创建</p><p>rmdir:文件夹删除</p></blockquote><blockquote><p>gedit xx.*:创建xx文件，类型为*</p><p>vi&#x2F;vim xx.* :创建xx文件，类型为*</p><p>rm xx.* :删除文件，配合sudo -rf，可以强制删除文件</p><p>mv :文件的移动or 重命名</p><p><strong>touch</strong>：touch a.c创建a.c文件</p><p><strong>cp</strong>:拷贝 cp a.c b.c 将a.c拷贝一份重命名为b.c</p><blockquote><p>在Linux中万物皆文件，所有上述命令可以创建修改大多数的文件类型</p></blockquote></blockquote><h3 id="权限操作："><a href="#权限操作：" class="headerlink" title="权限操作："></a><strong>权限操作：</strong></h3><blockquote><p><strong>su root：</strong> 切换超级管理员权限（上帝模式，要输密码）</p><p><strong>sudo su username</strong>：回归普通权限</p><p><strong>sudo 命令</strong>：将此命令以超级管理员权限执行</p><blockquote><p>sudo命令在大多数情况下被使用如：安装软件，强制完全删除，创建高权限文件</p></blockquote></blockquote><h3 id="日常命令："><a href="#日常命令：" class="headerlink" title="日常命令："></a><strong>日常命令：</strong></h3><blockquote><p>sudo dpkg -i ***.deb 安装deb软件</p><p>sudo dpkg -r *** 卸载软件包</p><blockquote><p>最简单的软件安装与卸载方法</p></blockquote></blockquote><blockquote><p>unzip 解压</p><p>unzip -o gb18030 example.zip 无乱码解压 </p><p>ln  -s  log2013.log  link2013 创建软连接</p></blockquote><blockquote><p>sudo spt-get install *** 插件依赖的安装</p><p>apt-get remove packagename：移除与<code>packagename</code>相关联的所有二进制文件，不会移除依赖、配置、数据</p><p>apt-get remove –purge packagename： 移除与包<code>packagename</code>相关联的所有文件，包括二进制文件和全局配置文件不会移除依赖</p><blockquote><p>用来安装一些常见的功能如：git ,tree,gcc，vim 等</p></blockquote></blockquote><blockquote><p>halt：立刻关机 </p><p>poweroff：立刻关机</p><p>shutdown -h now：立刻关机(root用户使用) </p><p>shutdown -h 10：10分钟后自动关机 </p><blockquote><p>注意，如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启</p></blockquote><p><strong>重启命令</strong></p><p>reboot 立即重启</p><p>shutdown -r now 立刻重启(root用户使用) </p><p>shutdown -r 10 过10分钟自动重启(root用户使用) </p><p>shutdown -r 20:35 在时间为20:35时候重启(root用户使用) </p><blockquote><p>如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启</p></blockquote><p><strong>推荐使用shutdown</strong></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客创建（hexo）</title>
      <link href="/2023/03/24/17-59-13/"/>
      <url>/2023/03/24/17-59-13/</url>
      
        <content type="html"><![CDATA[<h2 id="博客创建（hexo）"><a href="#博客创建（hexo）" class="headerlink" title="博客创建（hexo）:"></a><strong>博客创建（hexo）:</strong></h2><p>如果你也想要创建一个属于自己的博客</p><blockquote><p>可以参考[hexo框架的安装](<a href="https://www.cnblogs.com/chenlove/p/15058170.html">【保姆级】利用Github搭建自己的个人博客，看完就会 - Python研究者 - 博客园 (cnblogs.com)</a>)、[butterfly主题的安装](<a href="https://www.nickxu.top/2022/02/17/Hexo-Butterfly-%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89Butterfly-%E4%B8%BB%E9%A2%98/">Hexo + Butterfly 建站指南（三）Butterfly 主题 | NX の 博客 (nickxu.top)</a>)、[Butterfly配置](<a href="https://zhuanlan.zhihu.com/p/492207978">Hexo Butterfly主题相关配置 - 知乎 (zhihu.com)</a>)</p></blockquote><p>通过这些大神的文章，你也可以轻松搭建自己的博客。</p><hr><p>搭建博客时遇到的问题：</p><ol><li><p>git未配置：一般出现在最后的上传上，如果上传时出现错误，大概率是gi未下载</p><p>安装 npm install <code>--</code>save hexo-deployer-git 当然npm失败的可能性很大，可以</p><p>换淘宝源，使用cnpm 安装（具体方法自行百度）</p></li><li><p>[hexo框架的安装]([【保姆级】利用Github搭建自己的个人博客，看完就会 - Python研究者 - 博客园 (cnblogs.com)]) 环境在git命令环境，使用cmd也可以进行，但是最后的上传操</p><p>作容易失败。</p></li><li><p>主题的更换:hexo主题的更换尽量使用稳定版，next主题最新版不够稳定，容易出</p><p>现意想不到的错误。</p></li><li><p>butterfly 的 <strong>初始首页图片</strong> 与 <strong>文章顶部图片</strong> 的变换目前发现，本地图片无法成功替</p><p>换，可以自己搭建图床，或者直接在网上寻找自己喜欢的图片（图片链接不能过长）</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32简易整合系列库</title>
      <link href="/2023/03/23/22-49-44/"/>
      <url>/2023/03/23/22-49-44/</url>
      
        <content type="html"><![CDATA[<h2 id="这是一个通用型的STM32简易整合系列库，其搭配相关固件库进行工作。"><a href="#这是一个通用型的STM32简易整合系列库，其搭配相关固件库进行工作。" class="headerlink" title="这是一个通用型的STM32简易整合系列库，其搭配相关固件库进行工作。"></a>这是一个通用型的STM32简易整合系列库，其搭配相关固件库进行工作。</h2><hr><blockquote><p>我把STM32上的外设配置结构体进行了整合，单个功能只需要配置一个结构体，目前支持<del>STM32F103</del> (GPIO以支持，其他未完善)STM32F07 只需要对Common_Header.h相关宏定义进行即可</p></blockquote><hr><p>目前完成的都有：</p><ul><li><p><strong>Common_ETTI.c</strong> </p><blockquote><p>Common_ETTI.h 用于存放通用中断与相关函数  </p></blockquote></li><li><p><strong>Common_GPIO.c</strong></p><blockquote><p>Common_GPIO.h 用于存放GPIO的配置与相关函数  </p></blockquote></li><li><p><strong>Common_USART.c</strong></p><blockquote><p>Common_USART 用于存放USART的配置与相关函数  </p></blockquote></li><li><p><strong>Common_Header.h</strong></p><blockquote><p>存放本库所有可能用到的头文件  </p></blockquote></li><li><p><strong>Common_Struct.h</strong></p><blockquote><p>存放本库所有可能使用的结构体  </p></blockquote></li><li><p><strong>Common_TIM.c</strong></p><blockquote><p>Common_TIM用于存放定时器的配置与相关函数  </p></blockquote></li><li><p><strong>Common_PWM.c</strong></p></li></ul><blockquote><p>Common_PWM用于存放PWM的配置与相关函数  </p></blockquote><p>一般来说，Common_Struct.hCommon_Header.h   Common_XXX.c</p><p>三者为<strong>最小单元组</strong>，为了增强其可移植性，Common_XXX.c 之间相互独立</p><p>[点击此处转跳下载](<a href="https://github.com/jing314/-jing314-STM32_Easy_Common">jing314&#x2F;-jing314-STM32_Easy_Common (github.com)</a>)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于RS485，TTL，与串口之间关系的思考</title>
      <link href="/2023/03/23/22-16-15/"/>
      <url>/2023/03/23/22-16-15/</url>
      
        <content type="html"><![CDATA[<h2 id="关于RS485，TTL，与串口之间关系的思考"><a href="#关于RS485，TTL，与串口之间关系的思考" class="headerlink" title="关于RS485，TTL，与串口之间关系的思考"></a><a href="https://zhuanlan.zhihu.com/p/89240672">关于RS485，TTL，与串口之间关系的思考</a></h2><p>串口为硬件说法，</p><p>其主要特征为以下四个引脚：<strong>RXD、TXD、GND、VCC，</strong>（NC为空引脚）</p><blockquote><p><img src="https://pic4.zhimg.com/80/v2-e05744b45c367bcd299c74121c367eab_720w.webp" alt="https://pic4.zhimg.com/80/v2-e05744b45c367bcd299c74121c367eab_720w.webp"></p></blockquote><blockquote><p><img src="https://pic1.zhimg.com/80/v2-766cf4e0f6999d0b923ccbb694493f4c_720w.webp" alt="https://pic1.zhimg.com/80/v2-766cf4e0f6999d0b923ccbb694493f4c_720w.webp"></p></blockquote><p>其中RXD与TXD分别接收信号，GND、VCC用来负责供电，</p><ul><li><p>TTL，RS485，等等均为串口类型在不同信息协议下的不同名称。</p></li><li><p>TTL，RS485依据基于串口，不过将串口的数据格式通过芯片转换为了TTL，RS485的格式。</p></li><li><p>以一个不恰当的例子来说，串口相当与手机本身，而TTL，RS485相当与手机使用的操作系统。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
