<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>嵌入式C语言（宏定义）</title>
      <link href="/2023/03/28/16-00-44/"/>
      <url>/2023/03/28/16-00-44/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式C语言（宏定义）"><a href="#嵌入式C语言（宏定义）" class="headerlink" title="嵌入式C语言（宏定义）"></a>嵌入式C语言（宏定义）</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;头文件.h&quot; //引用头文件</span><br><span class="line"></span><br><span class="line">#define 宏名 宏体   // 宏定义</span><br><span class="line">#define STM32F10x  1 //将STM32F10x定义为1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="宏定义进阶"><a href="#宏定义进阶" class="headerlink" title="宏定义进阶"></a>宏定义进阶</h2><p><strong># 与 ##</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define STM32F10x #2763             //将STM32F10x替换为‘2763’（字符型）</span><br><span class="line"></span><br><span class="line">#define COMMON_TIM(x) TIM##(x)      // 将COMMON_TIM(x) 替换为TIM(x),如COMMON_TIM1 TIM1</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#if     条件1</span><br><span class="line"> //语句1</span><br><span class="line">#eli1f  条件2</span><br><span class="line"> //语句2</span><br><span class="line"> #endif </span><br><span class="line"></span><br><span class="line">#ifndef </span><br><span class="line">#define</span><br><span class="line">#endif </span><br><span class="line">与#if类似</span><br></pre></td></tr></table></figure><p>如果条件为1（真），则编译对应语句，</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void OUT_PP_Config(Common_GPIO_Sturct *Normal_GPIO_Init)</span><br><span class="line">&#123;</span><br><span class="line">#if STM32F10x</span><br><span class="line">    RCC_APB2PeriphClockCmd(Normal_GPIO_Init-&gt;RCC_AXXPeriph_GPIOX,ENABLE);</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;                   //推挽输出</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = STM32F10x_SPEED;   </span><br><span class="line">#elif STM32F4xx</span><br><span class="line">    RCC_AHB1PeriphClockCmd(Normal_GPIO_Init-&gt;RCC_AXXPeriph_GPIOX,ENABLE);       //开启时钟</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;</span><br><span class="line">    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;                           //上拉</span><br><span class="line">    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;                     //推挽输出模式</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = STM32F4xx_SPEED;   </span><br><span class="line">#endif</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = Normal_GPIO_Init-&gt;GPIO_PIN;                                  //配置引脚                                  </span><br><span class="line">    GPIO_Init(Normal_GPIO_Init-&gt;GPIOX,&amp;GPIO_InitStruct);</span><br><span class="line">    GPIO_SetBits(Normal_GPIO_Init-&gt;GPIOX,Normal_GPIO_Init-&gt;GPIO_PIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在头文件中修改STM32F10x，STM32F4xx的值即可切换版本</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gcc学习笔记</title>
      <link href="/2023/03/27/17-10-58/"/>
      <url>/2023/03/27/17-10-58/</url>
      
        <content type="html"><![CDATA[<h1 id="gcc学习笔记（无详细使用）"><a href="#gcc学习笔记（无详细使用）" class="headerlink" title="gcc学习笔记（无详细使用）"></a>gcc学习笔记（无详细使用）</h1><hr><h2 id="gcc-是什么"><a href="#gcc-是什么" class="headerlink" title="gcc 是什么"></a>gcc 是什么</h2><hr><blockquote><p>GCC : 英文全拼：GNU Compiler Collection，是 GNU 工具链的主要组成部分，是一套以 GPL 和 LGPL 许可证发布的程序语言编译器自由软件。</p></blockquote><blockquote><p>gcc ：GNU C Collection ，是一款C编译器，可以来编译C，C++</p></blockquote><blockquote><p>g++:GNU C++ Collection，是一款C++编译器，只C++专用</p></blockquote><p><strong>一般来说，gcc☞的都是GNU Compiler Collection，即GUN编译器合集</strong></p><hr><h2 id="gcc-怎么用"><a href="#gcc-怎么用" class="headerlink" title="gcc 怎么用"></a>gcc 怎么用</h2><hr><blockquote><p>gcc 在linux环境中通过命令来进行编译，在wins环境下，一般集成与单独的编译软件中，例如Dev-C++.</p><p>wins环境下，一般通过使用集成编译器间接使用（即图像化一键编译等等）,不过多解释。</p></blockquote><blockquote><p>另外，在Linux环境中，一般自带有gcc(C编译)，其他编译环境需要自行安装。linux下，通常以命令如：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o &#123;输出文件名&#125; &#123;输入文件名&#125;#-o与&#123;输出文件名&#125;之间不能有其他命令，两者可以看为一体</span><br><span class="line"></span><br><span class="line">#gcc对文件格式的识别是通过后缀进行的，后缀不同，gcc会选用不同的编译器</span><br></pre></td></tr></table></figure><blockquote><p> 另外的除了gcc命令外，还有g++命令,不过两者命令格式一样，不单独讨论了，只需要将命令中的gcc</p><p>换成g++即可</p></blockquote><p>具体使用可参考<a href="https://blog.csdn.net/Three_dog/article/details/103688043">g++编译详解</a>、<a href="https://zhuanlan.zhihu.com/p/380180101">gcc编译详解</a>。</p><hr><h2 id="gcc-什么时候用"><a href="#gcc-什么时候用" class="headerlink" title="gcc 什么时候用"></a>gcc 什么时候用</h2><hr><p>gcc，用在高级语言转机器语言的过程中，类似人与计算机之间的翻译员，将高级程序语言转化为二进制码</p><p>同时，其还可以找出高级语言中的语法错误，给出提示信息</p><p>我们也可以通过gcc获得相应高级语言的汇编语言、机器语言。</p><hr><h2 id="gcc的工作步骤"><a href="#gcc的工作步骤" class="headerlink" title="gcc的工作步骤"></a>gcc的工作步骤</h2><hr><blockquote><p>1、预处理 预编译，可以使用命令<code>gcc -E</code>执行</p></blockquote><blockquote><p>2、将预处理后的文件转换成汇编语言, 生成文件 .s      编译，可以使用<code>gcc -S</code>执行</p></blockquote><blockquote><p>3、有汇编变为目标代码(机器代码)生成 .o 的文件    汇编，可以使用<code>as</code> 或者<code>gcc -c</code>执行</p></blockquote><blockquote><p>4、连接目标代码, 生成可执行程序     链接，可以使用<code>gcc xxx.o xxx.so xxx.a</code>执行</p></blockquote><p>一步步向底层进发。gcc -o 【输出目标】 【输出目标】可以用不到位的进行，但本质上还是分布进行的</p><p>通过gcc -v -o 【输出目标】 【输出目标】可以显示他的编译步骤 (g++同理)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令笔记</title>
      <link href="/2023/03/24/18-40-36/"/>
      <url>/2023/03/24/18-40-36/</url>
      
        <content type="html"><![CDATA[<h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a><strong>linux常用命令</strong></h2><h3 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a><strong>文件操作：</strong></h3><blockquote><p><strong>cd</strong>:路径进入</p><p>cd 桌面 -进入桌面目录，cd &#x2F;进入根目录 ，**&#x2F;**代表根目录 ，..代表上一级，-代表当前目录</p></blockquote><blockquote><p><strong>ls</strong>：显示当前目录下文件</p><p>ls -a显示当前目录下所有文件（包括隐藏文件）</p></blockquote><blockquote><p>mkdir :文件夹创建</p><p>rmdir:文件夹删除</p></blockquote><blockquote><p>gedit xx.*:创建xx文件，类型为*</p><p>vi&#x2F;vim xx.* :创建xx文件，类型为*</p><p>rm xx.* :删除文件，配合sudo -rf，可以强制删除文件</p><p>mv :文件的移动or 重命名</p><p><strong>touch</strong>：touch a.c创建a.c文件</p><p><strong>cp</strong>:拷贝 cp a.c b.c 将a.c拷贝一份重命名为b.c</p><blockquote><p>在Linux中万物皆文件，所有上述命令可以创建修改大多数的文件类型</p></blockquote></blockquote><h3 id="权限操作："><a href="#权限操作：" class="headerlink" title="权限操作："></a><strong>权限操作：</strong></h3><blockquote><p><strong>su root：</strong> 切换超级管理员权限（上帝模式，要输密码）</p><p><strong>sudo su username</strong>：回归普通权限</p><p><strong>sudo 命令</strong>：将此命令以超级管理员权限执行</p><blockquote><p>sudo命令在大多数情况下被使用如：安装软件，强制完全删除，创建高权限文件</p></blockquote></blockquote><h3 id="日常命令："><a href="#日常命令：" class="headerlink" title="日常命令："></a><strong>日常命令：</strong></h3><blockquote><p>sudo dpkg -i ***.deb 安装deb软件</p><p>sudo dpkg -r *** 卸载软件包</p><blockquote><p>最简单的软件安装与卸载方法</p></blockquote></blockquote><blockquote><p>unzip 解压</p><p>unzip -o gb18030 example.zip 无乱码解压 </p><p>ln  -s  log2013.log  link2013 创建软连接</p></blockquote><blockquote><p>sudo spt-get install *** 插件依赖的安装</p><p>apt-get remove packagename：移除与<code>packagename</code>相关联的所有二进制文件，不会移除依赖、配置、数据</p><p>apt-get remove –purge packagename： 移除与包<code>packagename</code>相关联的所有文件，包括二进制文件和全局配置文件不会移除依赖</p><blockquote><p>用来安装一些常见的功能如：git ,tree,gcc，vim 等</p></blockquote></blockquote><blockquote><p>halt：立刻关机 </p><p>poweroff：立刻关机</p><p>shutdown -h now：立刻关机(root用户使用) </p><p>shutdown -h 10：10分钟后自动关机 </p><blockquote><p>注意，如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启</p></blockquote><p><strong>重启命令</strong></p><p>reboot 立即重启</p><p>shutdown -r now 立刻重启(root用户使用) </p><p>shutdown -r 10 过10分钟自动重启(root用户使用) </p><p>shutdown -r 20:35 在时间为20:35时候重启(root用户使用) </p><blockquote><p>如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启</p></blockquote><p><strong>推荐使用shutdown</strong></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客创建（hexo）</title>
      <link href="/2023/03/24/17-59-13/"/>
      <url>/2023/03/24/17-59-13/</url>
      
        <content type="html"><![CDATA[<h2 id="博客创建（hexo）"><a href="#博客创建（hexo）" class="headerlink" title="博客创建（hexo）:"></a><strong>博客创建（hexo）:</strong></h2><p>如果你也想要创建一个属于自己的博客</p><blockquote><p>可以参考[hexo框架的安装](<a href="https://www.cnblogs.com/chenlove/p/15058170.html">【保姆级】利用Github搭建自己的个人博客，看完就会 - Python研究者 - 博客园 (cnblogs.com)</a>)、[butterfly主题的安装](<a href="https://www.nickxu.top/2022/02/17/Hexo-Butterfly-%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89Butterfly-%E4%B8%BB%E9%A2%98/">Hexo + Butterfly 建站指南（三）Butterfly 主题 | NX の 博客 (nickxu.top)</a>)、[Butterfly配置](<a href="https://zhuanlan.zhihu.com/p/492207978">Hexo Butterfly主题相关配置 - 知乎 (zhihu.com)</a>)</p></blockquote><p>通过这些大神的文章，你也可以轻松搭建自己的博客。</p><hr><p>搭建博客时遇到的问题：</p><ol><li><p>git未配置：一般出现在最后的上传上，如果上传时出现错误，大概率是gi未下载</p><p>安装 npm install <code>--</code>save hexo-deployer-git 当然npm失败的可能性很大，可以</p><p>换淘宝源，使用cnpm 安装（具体方法自行百度）</p></li><li><p>[hexo框架的安装]([【保姆级】利用Github搭建自己的个人博客，看完就会 - Python研究者 - 博客园 (cnblogs.com)]) 环境在git命令环境，使用cmd也可以进行，但是最后的上传操</p><p>作容易失败。</p></li><li><p>主题的更换:hexo主题的更换尽量使用稳定版，next主题最新版不够稳定，容易出</p><p>现意想不到的错误。</p></li><li><p>butterfly 的 <strong>初始首页图片</strong> 与 <strong>文章顶部图片</strong> 的变换目前发现，本地图片无法成功替</p><p>换，可以自己搭建图床，或者直接在网上寻找自己喜欢的图片（图片链接不能过长）</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32简易整合系列库</title>
      <link href="/2023/03/23/22-49-44/"/>
      <url>/2023/03/23/22-49-44/</url>
      
        <content type="html"><![CDATA[<h2 id="这是一个通用型的STM32简易整合系列库，其搭配相关固件库进行工作。"><a href="#这是一个通用型的STM32简易整合系列库，其搭配相关固件库进行工作。" class="headerlink" title="这是一个通用型的STM32简易整合系列库，其搭配相关固件库进行工作。"></a>这是一个通用型的STM32简易整合系列库，其搭配相关固件库进行工作。</h2><hr><blockquote><p>我把STM32上的外设配置结构体进行了整合，单个功能只需要配置一个结构体，目前支持<del>STM32F103</del> (GPIO以支持，其他未完善)STM32F07 只需要对Common_Header.h相关宏定义进行即可</p></blockquote><hr><p>目前完成的都有：</p><ul><li><p><strong>Common_ETTI.c</strong> </p><blockquote><p>Common_ETTI.h 用于存放通用中断与相关函数  </p></blockquote></li><li><p><strong>Common_GPIO.c</strong></p><blockquote><p>Common_GPIO.h 用于存放GPIO的配置与相关函数  </p></blockquote></li><li><p><strong>Common_USART.c</strong></p><blockquote><p>Common_USART 用于存放USART的配置与相关函数  </p></blockquote></li><li><p><strong>Common_Header.h</strong></p><blockquote><p>存放本库所有可能用到的头文件  </p></blockquote></li><li><p><strong>Common_Struct.h</strong></p><blockquote><p>存放本库所有可能使用的结构体  </p></blockquote></li><li><p><strong>Common_TIM.c</strong></p><blockquote><p>Common_TIM用于存放定时器的配置与相关函数  </p></blockquote></li><li><p><strong>Common_PWM.c</strong></p></li></ul><blockquote><p>Common_PWM用于存放PWM的配置与相关函数  </p></blockquote><p>一般来说，Common_Struct.hCommon_Header.h   Common_XXX.c</p><p>三者为<strong>最小单元组</strong>，为了增强其可移植性，Common_XXX.c 之间相互独立</p><p>[点击此处转跳下载](<a href="https://github.com/jing314/-jing314-STM32_Easy_Common">jing314&#x2F;-jing314-STM32_Easy_Common (github.com)</a>)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于RS485，TTL，与串口之间关系的思考</title>
      <link href="/2023/03/23/22-16-15/"/>
      <url>/2023/03/23/22-16-15/</url>
      
        <content type="html"><![CDATA[<h2 id="关于RS485，TTL，与串口之间关系的思考"><a href="#关于RS485，TTL，与串口之间关系的思考" class="headerlink" title="关于RS485，TTL，与串口之间关系的思考"></a><a href="https://zhuanlan.zhihu.com/p/89240672">关于RS485，TTL，与串口之间关系的思考</a></h2><p>串口为硬件说法，</p><p>其主要特征为以下四个引脚：<strong>RXD、TXD、GND、VCC，</strong>（NC为空引脚）</p><blockquote><p><img src="https://pic4.zhimg.com/80/v2-e05744b45c367bcd299c74121c367eab_720w.webp" alt="https://pic4.zhimg.com/80/v2-e05744b45c367bcd299c74121c367eab_720w.webp"></p></blockquote><blockquote><p><img src="https://pic1.zhimg.com/80/v2-766cf4e0f6999d0b923ccbb694493f4c_720w.webp" alt="https://pic1.zhimg.com/80/v2-766cf4e0f6999d0b923ccbb694493f4c_720w.webp"></p></blockquote><p>其中RXD与TXD分别接收信号，GND、VCC用来负责供电，</p><ul><li><p>TTL，RS485，等等均为串口类型在不同信息协议下的不同名称。</p></li><li><p>TTL，RS485依据基于串口，不过将串口的数据格式通过芯片转换为了TTL，RS485的格式。</p></li><li><p>以一个不恰当的例子来说，串口相当与手机本身，而TTL，RS485相当与手机使用的操作系统。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
